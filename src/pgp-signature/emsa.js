import concatenate from "concat-buffers";
/*
13.1.3.  EMSA-PKCS1-v1_5
 Steps:

     1. Apply the hash function to the message M to produce a hash value
        H:

        H = Hash(M).

        If the hash function outputs "message too long," output "message
        too long" and stop.

     2. Using the list in Section 5.2.2, produce an ASN.1 DER value for
        the hash function used.  Let T be the full hash prefix from
        Section 5.2.2, and let tLen be the length in octets of T.

     3. If emLen < tLen + 11, output "intended encoded message length
        too short" and stop.

     4. Generate an octet string PS consisting of emLen - tLen - 3
        octets with hexadecimal value 0xFF.  The length of PS will be at
        least 8 octets.

     5. Concatenate PS, the hash prefix T, and other padding to form the
        encoded message EM as

        EM = 0x00 || 0x01 || PS || 0x00 || T.

     6. Output EM.
     */

// prettier-ignore
const EMSA_PKCS1_v1_5_HASH_PREFIX = {
  // 'MD5': [0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86,
  // 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00,
  // 0x04, 0x10],

  //    'RIPEMD-160': [0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24,
  // 0x03, 0x02, 0x01, 0x05, 0x00, 0x04, 0x14],

  SHA1: new Uint8Array([ 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14 ])

  //    'SHA224': [0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
  // 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05,
  // 0x00, 0x04, 0x1C],

  //    'SHA256': [0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
  // 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
  // 0x00, 0x04, 0x20],

  //    'SHA384': [0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
  // 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05,
  // 0x00, 0x04, 0x30],

  //    'SHA512': [0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
  // 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
  // 0x00, 0x04, 0x40]
};

// EMSA = Encoding Method for Signature with Appendix
export function encode(hashType, hash, length) {
  console.log(hashType, hash, length);
  const T = EMSA_PKCS1_v1_5_HASH_PREFIX[hashType];
  const tLen = T.length + hash.length;
  console.log("tLen", tLen);
  const paddingLength = length - tLen - 3;
  const padding = new Uint8Array(paddingLength);
  console.log("padding", padding);
  padding.fill(255);
  return concatenate([
    new Uint8Array([0, 1]),
    padding,
    new Uint8Array([0]),
    T,
    hash
  ]);
}
